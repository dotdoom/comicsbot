<html>
<head>
	<title>chatlogs</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/pikaday/1.4.0/pikaday.js" type="text/javascript"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/autolinker/0.25.1/Autolinker.min.js" type="text/javascript"></script>
	<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/pikaday/1.4.0/css/pikaday.min.css">
</head>
<body>

<style>
#log {
	font-family: "Courier New", Courier, monospace;
}

span.entry {
	display: block;
	cursor: pointer;
}

span.notification {
	color: olive;
}

span.highlighted {
	background-color: yellow;
}

span.searchMatch {
	background-color: magenta;
}

.unselectable {
	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
}
</style>

<form class="unselectable">
	<!--todo: make it float-->
Search logs (date or keywords or /regexp/): <input id="search" type="text" />
<input type="submit" value="Go" onclick="return searchFromElement()" />
<span id="search_status"></span>
<label><input id="show_statuses" type="checkbox" onclick="setShowStatusChanges()"/>Show status changes</label>
</form>
<div id="log"></div>

<script type="text/javascript">
var userColors = [
	"blue",
	"brown",
	"cadetblue",
	"darkviolet",
	"fuchsia",
	"indigo",
	"lime",
];

function stringHash(str) {
	var hash = 0, i, chr, len;
	if (str.length === 0) return hash;
	for (i = 0, len = str.length; i < len; i++) {
	    chr   = str.charCodeAt(i);
	    hash  = ((hash << 5) - hash) + chr;
	    hash |= 0; // Convert to 32bit integer
	}
	return hash;
}

function getHash() {
	var parsed = {};
	var parts = window.location.hash.slice(1).split("&");
	for (var i = 0; i < parts.length; i++) {
		var kv = parts[i].split("=", 2);
		parsed[kv[0]] = decodeURIComponent(kv[1]);
	}
	return parsed;
}

function setHash(value, overrideValue) {
	var overrideKey;
	if (typeof overrideValue !== "undefined") {
		overrideKey = value;
		value = settings;
	}
	var hash = [];
	for (key in value) {
		if (key != overrideKey && key) {
			hash.push(key + "=" + encodeURIComponent(value[key]));
		}
	}
	if (overrideKey) {
		hash.push(overrideKey + "=" + encodeURIComponent(overrideValue));
	}
	window.location.hash = "#" + hash.join("&");
}

function setShowStatusChanges() {
	setHash("statuses", document.getElementById("show_statuses").checked ? 1 : 0);
}

function pad(number, size) {
	number = "" + number;
	while (number.length < size) {
		number = "0" + number;
	}
	return number;
}

var settings = { statuses: 1 };

function dateFileName(d) {
	return d.getFullYear() + "-" +
			pad(d.getMonth() + 1, 2) + "-" +
			pad(d.getDate(), 2);
}

Pikaday.prototype.toString = function() {
	if (!this._d || !this._d.getTime || isNaN(this._d.getTime())) {
		return "";
	}
	return dateFileName(this._d);
}
new Pikaday({
	field: document.getElementById("search"),
	onSelect: searchFromElement,
});

function getCookie(name) {
	var cookies = document.cookie.split(";");
	for (var i = 0; i < cookies.length; i++) {
		var cookie = cookies[i].split("=");
		if (cookie[0].trim() == name) {
			return cookie[1];
		}
	}
}

function setCookie(name, value) {
	var data = name + "=" + value;
	var expiry = new Date();
	expiry.setDate(expiry.getDate() + 365);
	document.cookie = data + "; expires=" + expiry.toUTCString();
}

window.onhashchange = function() {
	var newSettings = getHash();
	if (!newSettings.search) {
		newSettings.search = dateFileName(new Date());
	}
	if (settings.search != newSettings.search) {
		displayHistoryObjects([]);
		search(newSettings.search);
	} else if (settings.highlight != newSettings.highlight) {
		highlightLine(settings.highlight, false);
		highlightLine(newSettings.highlight, true);
	}
	if (settings.statuses != newSettings.statuses) {
		if ("statuses" in newSettings) {
			settings.statuses = newSettings.statuses;
			setCookie("statuses", settings.statuses);
		} else {
			settings.statuses = getCookie("statuses");
			newSettings.statuses = settings.statuses;
		}
		displayHistoryObjects();
	}
	settings = newSettings;
	document.getElementById("search").value = settings.search;
	document.getElementById("show_statuses").checked = (settings.statuses != false);
};

var searchData = [],
	activeSearchId = 0;
document.onkeydown = function(e) {
	if (e.keyCode == 27) {
		activeSearchId += 1;
	}
}
function appendMultilineText(element, text) {
	var lines = text.split(/[\r\n]/gm);
	for (var i = 0; i < lines.length; i++) {
		if (i) {
			element.appendChild(document.createElement("br"));
		}
		element.appendChild(document.createTextNode(lines[i]));
	}
}
function filterAndAppend(pattern, data, date) {
	var changed = false;

	for (var i = 0; i < data.length; i++) {
		// TODO: extract to a separate method
		var text = entryText(data[i], true);
		if (pattern.exec) {
			pattern.lastIndex = 0;
			if (pattern.exec(text)) {
				changed = true;
				searchData.push(data[i]);
			}
		} else {
			var matched = true;
			for (var j = 0; j < pattern.length; j++) {
				if (pattern[j].toLowerCase() == pattern[j]) {
					if (text.toLowerCase().indexOf(pattern[j].toLowerCase()) < 0) {
						matched = false;
						break;
					}
				} else {
					if (text.indexOf(pattern[j]) < 0) {
						matched = false;
						break;
					}
				}
			}
			if (matched) {
				changed = true;
				searchData.push(data[i]);
			}
		}
	}
	if (changed) {
		date = date.getTime();
		searchData.sort(function(e1, e2) {
			return (Math.abs(e1.time * 1000 - date) -
				Math.abs(e2.time * 1000 - date));
		});
		displayHistoryObjects(searchData, true, textToHTMLConverter(pattern));
	}
}
function showSearchStatus(text) {
	document.getElementById("search_status").innerText = text;
}
function binarySearch(searchId, pattern, date, delta) {
	// That's actually "reverse" binary search.
	// Who would come up with such a stupid name for this method? Oh, wait...

	if ((delta > 365) || (searchId != activeSearchId)) {
		return showSearchStatus("");
	}

	var nextSearch = function() {
		if (delta > 0) {
			binarySearch(searchId, pattern, date, -delta);
		} else {
			binarySearch(searchId, pattern, date, -delta+1);
		}
	};

	var nextDate = new Date(date.getTime());
	nextDate.setDate(nextDate.getDate() + delta);

	var tooFarInFutureDate = new Date();
	tooFarInFutureDate.setDate(tooFarInFutureDate.getDate() + 3);
	if (nextDate.getTime() > tooFarInFutureDate.getTime()) {
		return nextSearch();
	}

	loadHistoryDate(dateFileName(nextDate), function(data) {
		filterAndAppend(pattern, data, date);
		showSearchStatus("Searching around " + date.toLocaleDateString() +
			"... ~" + (Math.abs(delta)*2) + " days (Esc to stop)");
		setTimeout(nextSearch, 100);
	});
}

function search(value) {
	// Disable previous search
	activeSearchId = activeSearchId + 1;
	searchData = [];

	value = value.trim();
	if (!value) {
		return;
	}

	var dateRegex = /^(\d{4})-(\d{2})-(\d{2})$/;
	if (dateRegex.exec(value)) {
		// Date match first
		return loadHistoryDate(value, function(data) {
			displayHistoryObjects(data, false);
		});
	}

	var startDate = new Date();
	dateRegex.lastIndex = 0;
	var match = dateRegex.exec(settings.search);
	if (match) {
		startDate.setFullYear(match[1]);
		startDate.setMonth(match[2]-1);
		startDate.setDate(match[3]);
	}
	var modifiers = "gm";
	if (value.toLowerCase() == value) {
		modifiers += "i";
	}
	if (value[0] == "/" && value[value.length-1] == "/") {
		value = value.slice(1, -1);
		if (!value) {
			return;
		}
		value = new RegExp(value, modifiers);
	} else {
		var parts = value.split(/\s+/);
		value = [];
		for (var i = 0; i < parts.length; i++) {
			if (parts[i]) {
				value.push(parts[i]);
			}
		}
	}
	binarySearch(activeSearchId, value, startDate, 0);
}

function searchFromElement(el) {
	setHash("search", document.getElementById("search").value);
	return false;
}

var historyCache = {};
function loadHistoryDate(date, callback) {
	if (historyCache[date]) {
		// Expiration?
		return callback(historyCache[date]);
	}

	var request = new XMLHttpRequest();
	request.onreadystatechange = function() {
		var DONE = this.DONE || 4;
		if (this.readyState === DONE) {
			var data;
			try {
				data = eval("[" + this.responseText + "]");
			} catch (e) {
				data = [];
			}
			historyCache[date] = data;
			callback(data);
		}
	};
	request.open("GET", "/log/" + date + ".json", true);
	request.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
	request.send(null);
}

function lineClicked() {
	var id = this.id;
	if (this.className.indexOf("highlighted") >= 0) {
		id = "";
	}
	setHash("highlight", id);
}

function highlightLine(id, highlighted) {
	if (!id) { return; }
	var line = document.getElementById(id);
	if (!line) { return; }
	if (highlighted && line.className.indexOf("highlighted") < 0) {
		line.className = "highlighted " + line.className;
		line.scrollIntoView();
	} else {
		line.className = line.className.replace("highlighted", "");
	}
}

function entryText(entry, showDate) {
	var text = "";
	if (entry.time) {
		var date = new Date(entry.time * 1000);
		text += "[";
		if (showDate) {
			text += date.toLocaleDateString() + " ";
		}
		text += date.toLocaleTimeString() + "] ";
	}
	if (entry.notification) {
		if (entry.user) {
			text += entry.user + " ";
		}
		text += entry.notification;
	} else {
		if (entry.user) {
			text += entry.user + ": ";
		} else {
			text += "System Message: ";
		}
		text += entry.message;
	}
	return text;
}

function textToHTMLConverter(pattern) {
	return function(entry, showDate, autolink) {
		var text = entryText(entry, showDate);
		var node = document.createElement("span");
		node.id = Math.round(entry.time * 1000);
		node.className = "entry";
		if (entry.notification) {
			node.className += " notification";
		} else {
			node.style.color = userColors[stringHash("" + entry.user) % userColors.length];
		}
		node.onclick = lineClicked;

		while (pattern) {
			if (pattern.exec) {
				pattern.lastIndex = 0;
				var match = pattern.exec(text);
				if (match && match[0].length) {
					appendMultilineText(node, text.slice(0, match.index));
					text = text.slice(match.index+match[0].length);
					matchNode = document.createElement("span");
					matchNode.className = "searchMatch";
					appendMultilineText(matchNode, match[0]);
					node.appendChild(matchNode);
				} else {
					break;
				}
			} else {
				var minIndex = text.length, length;
				for (var i = 0; i < pattern.length; i++) {
					var index;
					if (pattern[i].toLowerCase() == pattern[i]) {
						index = text.toLowerCase().indexOf(pattern[i].toLowerCase())
					} else {
						index = text.indexOf(pattern[i]);
					}
					if (index >= 0 && index < minIndex) {
						minIndex = index;
						length = pattern[i].length;
					}
				}
				// TODO: de-duplicate (see above)
				if (minIndex >= text.length) {
					break;
				} else {
					appendMultilineText(node, text.slice(0, minIndex));
					matchNode = document.createElement("span");
					matchNode.className = "searchMatch";
					appendMultilineText(matchNode, text.slice(minIndex,
								minIndex+length))
					node.appendChild(matchNode);
					text = text.slice(minIndex+length);
				}
			}
		}
		appendMultilineText(node, text);

		if (autolink) {
			node.innerHTML = Autolinker.link(node.innerHTML, {
				stripPrefix: false,
			});
		}

		return node;
	};
}

var lastDisplayHistoryObjectsArgs = [];
function displayHistoryObjects(data, showDate, converter) {
	if (!arguments.length) {
		data = lastDisplayHistoryObjectsArgs[0];
		showDate = lastDisplayHistoryObjectsArgs[1];
		converter = lastDisplayHistoryObjectsArgs[2];
	} else {
		lastDisplayHistoryObjectsArgs = arguments;
	}
	var log = document.getElementById("log"),
		autolink = false;
	while (log.firstChild) {
		log.removeChild(log.firstChild);
	}
	if (!converter) {
		converter = textToHTMLConverter();
		autolink = true;
	}
	var shownAnything = false;
	for (var i = 0; i < data.length; i++) {
		if ((settings.statuses != false) || !data[i].notification) {
			shownAnything = true;
			log.appendChild(converter(data[i], showDate, autolink));
		}
	}
	if (!shownAnything) {
		log.innerText = "No data found";
	} else {
		highlightLine(settings.highlight, true);
	}
}

window.onhashchange();
</script>

</body>
</html>
